# 图解密码技术_笔记

## 一、密码

### 0x01 环游密码世界

发送者(sender) 接受者(receiver) 窃听者(eavesdropper)

加密(encrypt) 解密(decrypt) 明文(plaintext) 密文(ciphertext)

破译者(cryptanalyst)  密码破译(cryptanalysis)

算法(algorithm) 密钥(key)  对称密码(symmetric cryptography)=私钥密码(secret-key cryptography)

公钥密码(public-key cryptography)=非对称密码(asymmetric cryptography)

混合密码系统(hybrid cryptosystem)

单向散列函数(one-way hash function)

散列值(hash)=哈希值=密码校验和(cryptographic checksum)=指纹(fingerprint)=消息摘要(message digest)

消息认证码(message authentication code)

### 0x02 历史上的密码

1. 凯撒密码--->平移位数--->暴力破解
2. 简单替换密码--->替换字母--->频率分析
3. Enigma--->使用轮子旋转，加密密钥--->加密两次输出、密码人为选定

### 0x03 对称密码

1. XOR(exclusive or)：将明文A用密钥B进行加密，得到密文A异或B；将密文A异或B用密钥B进行解密,得到明文A

2. 一次性密码：将明文与一串随机的比特序列进行XOR运算。因为暴力破解结果并不能判断是否得到真正明文，所以无法破解。在保存、同步、生成、配送上都有问题，难以应用。

3. DES

   ```
   64bit明文加密成64bit密文，密钥长56bit(规格64，每7位有1纠错bit)
   DES是一种16轮循环的Feistel网络，一轮步骤如下，每轮左右侧互换
   1.将输人的数据等分为左右32bit两部分。
   2.将输人的右侧直接发送到输出的右侧。
   3.将输入的右侧发送到轮函数。
   4.轮函数根据右侧数据和子密钥(),计算出一串看上去是随机的比特序列。
   5.将上一步得到的比特序列与左侧数据进行XOR运算,并将结果作为加密后的左侧。
   ```

4. 三重DESTDEA(Triple Date Encryption Algorithm)

   ```
   三个密钥，分别对明文进行加密，解密，加密；所以3DES若3个密钥相同，则等于DES
   ```

5. AES(Advanced Encryption Standard)

   ```
   2000年从多个候选算法中选中Rijndael()的对称密码算法；要求代码公开，无条件免费供给全世界使用。
   分组长度固定128bit，密钥长度有128/192/256bit三种
   ```

6. Rijindael

   ```
   比利时密码学家Joan Daemen与Vincent Rijmen
   分组长度和密钥长度支持以32bit为单位在128-256bit范围选择。
   Rijindael使用SPN结构多轮运算，每轮有SubBytes,ShiftRows,MixColumns,AddRoundKey共4个步骤。
   1.输入分组为128bit(16byte)，逐byte对16byte进行SbubBytes(简单替换密码256个值)处理；
   2.ShiftRows处理，将4byte为单位行向左平移，每行移动字节不同，即凯撒密码；
   3.MixColumns处理，对任意行列的4byte值进行比特运算；
   4.AddRoundKey处理，将轮密钥与3的输出进行XOR。
   ```

7. 流密码(stream cipher)：对数据流进行连续处理的一类密码算法。以1/8/32bit等为单位加密解密。一次性密码属于流密码。



### 0x04 分组密码的模式

1. ECB：Electronic CodeBook mode(电子密码本模式)

   ```
   相同的明文会被转换为相同的密文分组，最后一个小于分组长度时，使用特定数据填充。
   明文分组与密文分组一一对应，导致可以在不知道密钥情况下对任意密文分组进行替换，这样明文也会被替换
   ```

   

2. CBC：Cipher Block Chaining mode(密码分组链接模式)

   ```
   将明文分组与前一个密文分组进行XOR运算，然后再进行加密。
   第一个明文分组需要初始化向量(Initialization Vector,缩写IV)
   比特反转攻击（通过对IV进行比特反转来对明文分组攻击）
   填充提示攻击（反复发送一段密文，对填充数据进行少许改变，通过返回错误消息获得明文信息）
   应用：SSL/TLS
   ```

   

3. CFB：Cipher FeedBack mode(密文反馈模式)

   ```
   前一个密文进行加密后与明文分组直接进行XOR运算得到密文分组（解密用相同的密钥流对密文XOR）
   需要IV
   前一个密文分组是后一个的随机比特序列，称为密钥流(key stream)
   使用分组密码实现流密码
   重放攻击
   ```

   

4. OFB：Output FeedBack mode(输出反馈模式)

   ```
   IV经过4次加密后分别与4个明文分组进行XOR输出密文分组（解密用相同的密钥流对密文XOR）
   ```

   

5. CTR：CounTeR mode(计数器模式)

   ```
   对计数器进行加密，得到比特序列，与明文分组进行XOR（解密用相同的密钥流对密文XOR）
   ```

   

### 0x05 公钥密码

```
加法与减法：加x取余可以达到与减y相同的效果
乘法：多次相加
除法：乘法逆运算，将右边结果化为1，则变成了找倒数；0没有倒数，1只有1，其他可以通过与模值最大公约数是否为1判断（与模互质）
乘方：n次方，此时可以在两数直接进行取模，此方法即RSA所采取方法
对数：乘方的逆运算，乘方取模取对数称为离散对数；n次方 mod x = y ，此时次方值为离散对数
缺点：无法抵御中间人攻击、处理速度慢
```

1. RSA

   ```
   公钥密码算法，由Ron Rivest,Adi Shamir,Leonard Adleman开发，被广泛运用于公钥密码和数字签名。
   加密：密文 = 明文E次方 mod N    E(encryption)与N(number) {E,N}即公钥
   解密：明文 = 密文D次方 mod N    {D,N}即私钥
   求E,D,N数值就是生成密钥对，RSA生成密钥对步骤如下：
   1.求N：准备大质数p,q(伪随机数生成), p × q = N
   2.求L：仅生成密钥对出现。L = lcm(p-1,q-1), p-1和q-1的最小公倍数(least common multiple)
   3.求E：1<E<L；gcd(E,L) = 1, E与L的最大公约数(greatest common divisor)必须为1,即互质；通过伪随机数生成范围内数，再判断是否互质，
   4.求D：1<D<L；E × D mod L = 1, E与D互为倒数， 此时E×D必然大于L
   
   攻击：求离散对数(E,N,明文)；暴力破解(尝试D)；通过E,N求D(无L则不可能)；对N质因数分解(对大整数分解的高效算法)；求D(时间多项式等价N分解)；中间人攻击(更改加密公钥，让受害者使用攻击者的公钥加密)
   
   RSA-OPEP(optimal asymmetric encryption padding)最优非对称加密填充，在明文前面填充一些认证信息，
   ```

2. ElGamal：利用mod N下求离散对数的困难度

3. Rabin：利用mod  N下求平方根的困难度

4. 椭圆曲线(Elliptic Curve Cryptography,ECC)：通过将椭圆曲线上的特定点进行特殊的乘法运算实现，利用乘法逆运算非常困难特性。

### 0x06 混合密码系统

加密者将伪随机数生成的密钥用公钥进行加密，然后配送；传输过程的长消息用伪随机密钥对称加密后进行传输；

解密者收到后用私钥解密出密钥，再用密钥解密长消息；

组成部分：

1. 伪随机数生成器：生成器算法需要强，密钥空间足够大；
2. 对称密码：高强度对称密码算法，并确保密钥足够长度，还有合适的分组密码模式；
3. 公钥密码：高强度公钥密码算法，确保密钥长度；

应用：PGP、SSL/TLS



## 二、认证

### 0x07 单向散列函数---完整性

用于确保数据的完整性

性质：任意长度输入计算固定长度输出(256bit(32byte))、快速计算、弱抗碰撞性(找和该条消息具有相同散列值的另外一条消息是非常困难)、强抗碰撞性(散列值任意，找散列值相同的两条不同信息非常困难)、单向性、

应用：检测软件是否被篡改；基于口令的加密(passsword based encryption,将口令和盐混合后计算其散列值)；消息认证码；数字签名；伪随机数生成器；一次性口令；

```
MD4：Rivest设计,产生128bit的散列值(RFC1186)
MD5：Rivest设计,产生128bit的散列值(RFC1321)，强抗碰撞性已被攻破
SHA-1:NIST设计，产生160bit的散列值，强抗碰撞性2005年已被攻破，输入上限为2的64次方-1bit
SHA-2：输入上限为2的1288次方-1bit
	SHA-256/384/512:NIST设计，产生256/384/512bit的散列值，
RIPEMD-160：1996年由Hans Dobbertin、Antoon Bosselaers和Bart Preneel设计，产生160bit的散列值，
SHA-3:公开选拔，Keccak算法被选中（采用了与SHA-2完全不同的结构；结构清晰，易于分析；能够适用于各种设备，也适用于嵌入式应用；在硬件上的实现显示出了很高的性能；比其他最终候选算法安全性边际更大）；可以生成任意长度的散列值；
```

Keccak海绵结构：

- 吸收阶段(absoring phase)
  1. 输入进行每r bit分组，不足填充
  2. 内部状态b(r+c)bit为0，前r bit与输入分组1进行XOR，结果作为函数f输入值，c直接往后一直继承；
  3. 将函数f输入值与输入分组2进行XOR，一直循环；
  4. 处理完所有分组后，结束；r的内容全靠输入，称为比特率bit rate，影响输出，c不受内容分组直接影响，被称为容量capacity，防止泄露
- 挤出阶段(squeezing phase)
  1. 将函数f的输出值的r bit保存为输出分组1，并将输出值(r+c)再次输入到函数f中；
  2. 将函数f的输出值的r bit保存为输出分组2，并将输出值(r+c)再次输入到函数f中；
  3. 重复执行，直到获得想要的长度；
- 双工结构：输入与输出一起进行，用于伪随机数生成器、流密码、认证加密、消息认证码
- 内部状态：三维比特数组

对散列函数的攻击：

- 暴力破解：已知散列值，找另一个散列值相同的消息，对弱抗碰撞性进行攻击，攻击次数可通过散列值长度计算（原像攻击Pre-Image Attack）
- 生日攻击：找散列值相同的两条消息，散列值任意，对强抗碰撞性进行攻击（第二原像攻击Second Pre-Image Attack）

### 0x08 消息认证码---完整性与认证

MAC(Message Authentication Code)用于确认完整性并认证的技术，输入任意长度消息和共享密钥，输出固定长度数据MAC值。要计算MAC值必须有共享密钥，没有就无法计算MAC值，通过此完成认证，加上对MAC值进行单向散列函数计算，可以确保完整性。

1. 发送者Alice与接收者Bob事先共享密钥。
2. 发送者Alice根据汇款请求消息计算MAC值（使用共享密钥）。
3. 发送者Alice将汇款请求消息和MAC值两者发送给接收者Bob。
4. 接收者Bob根据接收到的汇款请求消息计算MAC值（使用共享密钥）。
5. 接收者Bob将自己计算的MAC值与从Alice处收到的MAC值进行对
6. 如果两个MAC值一致，则接收者Bob就可以断定汇款请求的确来自Alice(认证成功）;如果不一致，则可以断定消息不是来自Alice(认证失败）。

应用：SWIFT（Society for Worldwide Interbank Financial Telecommunication）银行之前通信使用，在公钥密码进行交换前进行消息认证，共享密钥使用人进行配送；IPsec；SSL/TLS；

实现方法：

1. 单向散列函数SHA-2实现---HMAC；
2. 分组密码密钥实现AES---CMAC；
3. 流密码和公钥密码；

认证加密AE：将对称密码和消息认证码相结合，同时满足机密性，完整性，认证三大功能---Encrypt-then-MAC（用对称密码加密明文，再计算密文MAC值）；Encrypt-and-MAC（将明文用对称密码加密，并对明文计算MAC值）；MAC-then-Encrypt（先计算明文的MAC值，然后将明文和MAC值同时用对称密码加密）；GCM（使用AES的CTR模式，并使用一个反复进行加法和乘法运算的散列函数来计算MAC值）

消息认证攻击（防御）：重放（序号，时间戳，随机数nonce）；密钥推测攻击（不能让MAC值反推出密钥）

### 0x09 数字签名---防止否认

私钥加密生成签名，公钥解密验证签名 

通过单向散列函数计算散列值，再对散列值进行数字签名。

应用：安全信息公告（不加密消息，只对消息进行数字签名）；软件下载；公钥证书（对公钥签名）；SSL/TLS

RSA生成签名：签名=消息D次方 mod N

RSA验证签名：签名求的消息=签名E次方 mod N

### 0x10 证书---对第三方证明

公钥证书（Public-Key Certificate,PKC)，认证机构（Certification Authority、CertifyingAuthority,CA)施加数字签名

1. Bob生成密钥对
2. Bob在认证机构Trent注册自己的公钥
3. 认证机构Trent用自己的私钥对Bob的公钥施加数字签名并生成证书
4. Alice得到带有认证机构Trent的数字签名的Bob的公钥（证书）
5. Alice使用认证机构Trent的公钥验证数字签名，确认Bob的公钥的合法性
6. Alice用Bob的公钥加密消息并发送给Bob
7. Bob用自己的私钥解密密文得到Alice的消息

公钥基础设施（Public-Key Infrastructure)是为了能够更有效地运用公钥而制定的一系列规范和规格的总称。

- 用户
  1. 【注册公钥的用户所进行的操作】
     生成密钥对（也可以由认证机构生成）
     在认证机构注册公钥
     向认证机构申请证书
     根据需要申请作废已注册的公钥
     解密接收到的密文
     对消息进行数字签名
  2. 【使用已注册公钥的用户所进行的操作】
     ·将消息加密后发送给接收者
     ·验证数字签名
- 认证机构CA
  1. ·生成密钥对（也可以由用户生成）
     ·在注册公钥时对本人身份进行认证
     ·生成并颁发证书
     ·作废证书
- 仓库：保存证书目录

攻击：公钥注册前进行攻击；注册相似人名；窃取认证机构私钥；伪装成认证机构；钻CRL空子时间差；

## 三、密钥，随机数与应用技术

### 0x11 密钥

密钥与明文等价，信息的机密性不应该依赖于密码算法本身，而是应该依赖于妥善保管的密钥。

Diffie-Hellman 密钥交换（Diffie-Hellman key exchange)，使用这种算法，通信双方仅通过交换一些可以公开的信息就能够生成出共享的秘密数字，而这一秘密数字就可以被用作对称密码的密钥。IPsec中就使用了经过改良的Diffie-Hellman密钥交换。根据有限域的离散对数问题而产生。

1. Alice 向 Bob 发送两个质数 P 和 G，P必须非常大，G是P的生成元，不需保密，谁生成都行
2. Alice生成一个随机数A，A是一个1~P-2之间的整数。保密
3. Bob生成一个随机数B，B是一个1~P-2之间的整数。保密
4. Alice 将 G的A次方 mod P 这个数发送给 Bob，不需保密
5. Bob将G的B次方 mod P 这个数发送给 Alice，不需保密
6. Alice 用 Bob 发过来的数计算 A 次方并求 mod P，共享密钥=G的 A×B次方 mod P，Bob同理

### 0x12 随机数

- 随机性——不存在统计学偏差，是完全杂乱的数列
- 不可预测性——不能从过去的数列推测出下一个出现的数
- 不可重现性——除非将数列本身保存下来，否则不能重现相同的数列

伪随机数生成器：软件实现，无法真正生成真随机数；具有内部状态，通过外部输入的种子生成随机数列

方法：

- 杂乱的方法：周期短、算法差
- 线性同余法(linear congruential method)：(A×内部状态+C) mod M，不具备不可预测性
- 单向散列函数法：内部状态作为计数器，散列函数计算内部状态输出即随机值，具备不可预测
- 密码法：用机密性确保伪随机数不可预测性。用密钥将随机数加密
- ANSI X9.17：将时间与内部状态XOR后加密输出，用于pgp

### 0x13 PGP

pretty good privacy，密码软件，由用户自己决定信任谁

### 0x14 SSL/TLS

用于承载HTTP，SMTP，POP3等协议，当使用SSL/TLS时，URL以https开头。

TLS协议是由TLS记录协议（TLS record protocol)和TLS握手协议（TLS handshake protocol)这两层协议叠加而成的。位于底层的TLS记录协议负责进行加密，而位于上层的TLS握手协议则负责除加密以外的其他各种操作。上层的TLS握手协议又可以分为4个子协议（握手协议，密码规格变更协议，警告协议，应用数据协议）。

TLS握手协议中的密码技术：

| 密码技术       | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| 公钥密码       | 加密预备主密码                                               |
| 单向散列函数   | 构成伪随机数生成器                                           |
| 数字签名       | 验证服务器和客户端的证书                                     |
| 伪随机数生成器 | 生成预备主密码<br/>根据主密码生成密钥（密码参数）<br/>生成初始化向量 |

TLS记录协议的密码技术：

| 密码技术     | 作用                         |
| ------------ | ---------------------------- |
| 对称密码CBC  | 确保片段机密性               |
| 消息认证码   | 确保片段完整性并认证         |
| 认证加密AEAD | 确保片段机密性和完整性并认证 |

攻击：密码技术；OpenSSL心脏出血；POODLE攻击；FREAK攻击和密码产品出口管制；对伪随机数生成器攻击；利用证书时间差；

### 0x15 密码技术与现实社会

**对称密码**是一种用相同的密钥进行加密和解密的技术，用于确保消息的机密性。在对称密码的算法方面，目前主要使用的是AES。尽管对称密码能够确保消息的机密性，但需要解决将解密密钥配送给接收者的密钥配送问题。

**公钥密码**是一种用不同的密钥进行加密和解密的技术，和对称密码一样用于确保消息的机密性。使用最广泛的一种公钥密码算法是RSA,除此之外还有EIGamal和Rabin等算法，以及与其相关Diffie-Hellman密钥交换（DH)和桐圆曲线Diffie-Hellman密钥交换（ECDH)等技术和对称密码相比，公钥密码的速度非常慢，因此一般都会和对称密码一起组成混合密码系统来使用。公钥密码能够解决对称密码中的密钥交换问题，但存在通过中间人攻击被伪装的风险因此需要对带有数字签名的公钥进行认证。

**单向散列函数**是一种将长消息转换为短散列值的技术，用于确保消息的完整性。在单向散列函数的算法方面，SHA-1曾被广泛使用，但由于人们已经发现了一些针对该算法的理论上可行的攻击方式，因此该算法不应再被用于新的用途。今后我们应该主要使用的算法包括目前已经在广泛使用的SHA-2(SHA-224、SHA-256、SHA-384、SHA-512),以及具有全新结构的SHA-3(Keccak)算法。单向散列函数可以单独使用，也可以作为消息认证码、数字签名以及伪随机数生成器等技术的组成元素来使用。

**消息认证码**是一种能够识别通信对象发送的消息是否被墓改的认证技术，用于验证消息的完整性，以及对消息进行认证。消息认证码的算法中，最常用的是利用单向散列函数的HMAC。HMAC的构成不依赖于某一种具体的单向散列函数算法。消息认证码能够对通信对象进行认证，但无法对第三方进行认证。此外，它也无法防止否认。消息认证码也可以用来实现认证加密。

**数字签名**是一种能够对第三方进行消息认证，并能够防止通信对象做出否认的认证技术。数字签名的算法包括RSA、EIGamal、DSA、楠圆曲线DSA(ECDSA)、爱德华兹曲线DSA(EDDSA)等。公钥基础设施（PKI)中使用的证书，就是对公钥加上认证机构的数字签名所构成的。要验证公钥的数字签名，需要通过某种途径获取认证机构自身的合法公钥。

**伪随机数生成器**是一种能够生成具备不可预测性的比特序列的技术，由密码和单向散列函数等技术构成。伪随机数生成器用于生成密钥、初始化向量和nonce等。

压缩技术：

- 和确保整个明文的机密性相比，确保**密钥的机密性**更容易，因此使用**密码**
- 和检查整个消息的完整性相比，检查**散列值的完整性**更容易，因此我们使用**单向散列函数**
- 和对整个消息进行认证相比，对**MAC值认证**更容易，因此使用**消息认证码**
- 和对整个消息进行认证相比，对**签名进行认证**更容易，使用**数字签名**
- 和确保整个随机数列的不可预测性相比，确保**随机数种子的不可预测性**更容易，使用**伪随机数生成器**

总结：

- 密钥是机密性的精华
- 散列值是完整性的精华
- 认证符号（MAC值和签名）是认证的精华
- 种子是不可预测性的精华

